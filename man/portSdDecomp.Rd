% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/portSdDecomp.R
\name{portSdDecomp}
\alias{portSdDecomp}
\alias{portSdDecomp.ffm}
\alias{portSdDecomp.tsfm}
\title{Decompose portfolio standard deviation into individual factor contributions}
\usage{
portSdDecomp(object, ...)

\method{portSdDecomp}{tsfm}(object, weights = NULL,
  use = "pairwise.complete.obs", ...)

\method{portSdDecomp}{ffm}(object, weights = NULL, ...)
}
\arguments{
\item{object}{fit object of class \code{tsfm}, or \code{ffm}.}

\item{...}{optional arguments passed to \code{\link[stats]{cov}}.}

\item{use}{an optional character string giving a method for computing 
covariances in the presence of missing values. This must be (an 
abbreviation of) one of the strings "everything", "all.obs", 
"complete.obs", "na.or.complete", or "pairwise.complete.obs". Default is 
"pairwise.complete.obs".}
}
\value{
A list containing 
\item{Sd.fm}{length-1 vector of factor model SDs of portfolio return.}
\item{mSd}{length-(N + K) vector of marginal contributions to SD.}
\item{cSd}{length-(N + K) vector of component contributions to SD.}
\item{pcSd}length-{(N + K) vector of percentage component contributions to SD.}
Where, \code{K} is the number of factors and N is the number of assets.
}
\description{
Compute the factor contributions to standard deviation (SD) of 
portfolio return based on Euler's theorem, given the fitted factor model.
}
\details{
The factor model for a portfolio's return at time \code{t} has the 
form \cr \cr \code{R(t) = beta'f(t) + e(t) = beta.star'f.star(t)} \cr \cr 
where, \code{beta.star=(beta,sig.e)} and \code{f.star(t)=[f(t)',z(t)]'}. 
\cr \cr By Euler's theorem, the standard deviation of the asset's return 
is given as: \cr \cr 
\code{Sd.fm = sum(cSd_k) = sum(beta.star_k*mSd_k)} \cr \cr 
where, summation is across the \code{K} factors and the residual, 
\code{cSd} and \code{mSd} are the component and marginal 
contributions to \code{SD} respectively. Computing \code{Sd.fm} and 
\code{mSd} is very straight forward. The formulas are given below and 
details are in the references. The covariance term is approximated by the 
sample covariance. \cr \cr
\code{Sd.fm = sqrt(beta.star''cov(F.star)beta.star)} \cr 
\code{mSd = cov(F.star)beta.star / Sd.fm}
}
\examples{
# Time Series Factor Model
data(managers)
fit.macro <- fitTsfm(asset.names=colnames(managers[,(1:6)]),
                     factor.names=colnames(managers[,(7:9)]),
                     rf.name="US.3m.TR", data=managers)
decomp <- fmSdDecomp(fit.macro)
# get the factor contributions of risk
decomp$cSd
# random weights
wts = runif(6)
wts = wts/sum(wts)
portSdDecomp(fit.cross, wts) 

# Fundamental Factor Model
data("stocks145scores6")
dat = stocks145scores6
dat$DATE = as.yearmon(dat$DATE)
dat = dat[dat$DATE >=as.yearmon("2008-01-01") & dat$DATE <= as.yearmon("2012-12-31"),]

#Load long-only GMV weights for the return data
data("wtsStocks145GmvLo")
wtsStocks145GmvLo = round(wtsStocks145GmvLo,5)  
                                                     
#fit a fundamental factor model
fit.cross <- fitFfm(data = dat, 
              exposure.vars = c("SECTOR","ROE","BP","PM12M1M","SIZE","ANNVOL1M","EP"),
              date.var = "DATE", ret.var = "RETURN", asset.var = "TICKER", 
              fit.method="WLS", z.score = TRUE)
decomp = portSdDecomp(fit.cross) 
# get the factor contributions of risk 
decomp$cSd
portSdDecomp(fit.cross, wtsStocks145GmvLo)               
 
}
\author{
Douglas Martin, Lingjie Yi
}

