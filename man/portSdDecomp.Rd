% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/portSdDecomp.R
\name{portSdDecomp}
\alias{portSdDecomp}
\alias{portSdDecomp.ffm}
\alias{portSdDecomp.tsfm}
\title{Decompose portfolio standard deviation into individual factor contributions}
\usage{
portSdDecomp(object, ...)

\method{portSdDecomp}{tsfm}(object, weights = NULL,
  use = "pairwise.complete.obs", ...)

\method{portSdDecomp}{ffm}(object, weights = NULL, ...)
}
\arguments{
\item{object}{fit object of class \code{tsfm}, or \code{ffm}.}

\item{...}{optional arguments passed to \code{\link[stats]{cov}}.}

\item{weights}{a vector of weights of the assets in the portfolio. Default is NULL, 
in which case an equal weights will be used.}

\item{use}{an optional character string giving a method for computing 
covariances in the presence of missing values. This must be (an 
abbreviation of) one of the strings "everything", "all.obs", 
"complete.obs", "na.or.complete", or "pairwise.complete.obs". Default is 
"pairwise.complete.obs".}
}
\value{
A list containing 
\item{portSd}{factor model Sd of portfolio return.}
\item{mSd}{length-(K + 1) vector of marginal contributions to Sd.}
\item{cSd}{length-(K + 1) vector of component contributions to Sd.}
\item{pcSd}{length-(K + 1) vector of percentage component contributions to Sd.}
Where, K is the number of factors.
}
\description{
Compute the factor contributions to standard deviation (Sd) of 
portfolio returns based on Euler's theorem, given the fitted factor model.
}
\details{
The factor model for a portfolio's return at time \code{t} has the 
form \cr \cr \code{R(t) = beta'f(t) + e(t) = beta.star'f.star(t)} \cr \cr 
where, \code{beta.star=(beta,sig.e)} and \code{f.star(t)=[f(t)',z(t)]'}. 
\cr \cr By Euler's theorem, the standard deviation of the portfolio's return 
is given as: \cr \cr 
\code{portSd = sum(cSd_k) = sum(beta.star_k*mSd_k)} \cr \cr 
where, summation is across the \code{K} factors and the residual, 
\code{cSd} and \code{mSd} are the component and marginal 
contributions to \code{SD} respectively. Computing \code{portSd} and 
\code{mSd} is very straight forward. The formulas are given below and 
details are in the references. The covariance term is approximated by the 
sample covariance. \cr \cr
\code{portSd = sqrt(beta.star''cov(F.star)beta.star)} \cr 
\code{mSd = cov(F.star)beta.star / portSd}
}
\examples{
# Time Series Factor Model
data(managers)
fit.macro <- factorAnalytics::fitTsfm(asset.names=colnames(managers[,(1:6)]),
                     factor.names=colnames(managers[,(7:9)]),
                     rf.name="US.3m.TR", data=managers)
decomp <- portSdDecomp(fit.macro)
# get the factor contributions of risk
decomp$cSd

# random weights 
wts = runif(6)
wts = wts/sum(wts)
names(wts) <- colnames(managers)[1:6]
portSdDecomp(fit.macro, wts)

# Fundamental Factor Model
data("stocks145scores6")
dat = stocks145scores6
dat$DATE = as.yearmon(dat$DATE)
dat = dat[dat$DATE >=as.yearmon("2008-01-01") & 
          dat$DATE <= as.yearmon("2012-12-31"),]

# Load long-only GMV weights for the return data
data("wtsStocks145GmvLo")
wtsStocks145GmvLo = round(wtsStocks145GmvLo,5)  
                                                     
# fit a fundamental factor model
fit.cross <- fitFfm(data = dat, 
              exposure.vars = c("SECTOR","ROE","BP","MOM121","SIZE","VOL121",
              "EP"),date.var = "DATE", ret.var = "RETURN", asset.var = "TICKER", 
              fit.method="WLS", z.score = TRUE)
              
decomp = portSdDecomp(fit.cross) 
# get the factor contributions of risk 
decomp$cSd
portSdDecomp(fit.cross, wtsStocks145GmvLo)               
 
}
\author{
Douglas Martin, Lingjie Yi
}
\seealso{
\code{\link{fitTsfm}}, \code{\link{fitFfm}}
for the different factor model fitting functions.

\code{\link{portVaRDecomp}} for portfolio factor model VaR decomposition.
\code{\link{portEsDecomp}} for portfolio factor model ES decomposition.
}

